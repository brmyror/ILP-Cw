<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/mapper/DroneServicePointMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/mapper/DroneServicePointMapper.java" />
              <option name="originalContent" value="package uk.ac.ed.acp.cw2.mapper;&#10;&#10;import uk.ac.ed.acp.cw2.dto.DroneServicePointDto;&#10;import uk.ac.ed.acp.cw2.dto.LngLat;&#10;import uk.ac.ed.acp.cw2.entity.DroneServicePoint;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;public final class DroneServicePointMapper {&#10;    private DroneServicePointMapper() {}&#10;&#10;    public static DroneServicePoint fromDto(DroneServicePointDto dto) {&#10;        if (dto == null) return null;&#10;&#10;        LngLat location = LngLat.builder()&#10;                .lng(dto.longitude())&#10;                .lat(dto.latitude())&#10;                .build();&#10;&#10;        return DroneServicePoint.builder()&#10;                .id(dto.id())&#10;                .name(dto.name())&#10;                .location(location)&#10;                .build();&#10;    }&#10;&#10;    public static List&lt;DroneServicePoint&gt; fromDtoList(DroneServicePointDto[] dtos) {&#10;        return Arrays.stream(dtos)&#10;                .map(DroneServicePointMapper::fromDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package uk.ac.ed.acp.cw2.mapper;&#10;&#10;import uk.ac.ed.acp.cw2.dto.DroneServicePointDto;&#10;import uk.ac.ed.acp.cw2.dto.LngLat;&#10;import uk.ac.ed.acp.cw2.entity.DroneServicePoint;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;public final class DroneServicePointMapper {&#10;    private DroneServicePointMapper() {}&#10;&#10;    public static DroneServicePoint fromDto(DroneServicePointDto dto) {&#10;        if (dto == null) return null;&#10;&#10;        LngLat location = LngLat.builder()&#10;                .lng(dto.longitude())&#10;                .lat(dto.latitude())&#10;                .build();&#10;&#10;        return DroneServicePoint.builder()&#10;                .id(dto.id())&#10;                .name(dto.name())&#10;                .location(location)&#10;                .build();&#10;    }&#10;&#10;    public static List&lt;DroneServicePoint&gt; fromDtoList(DroneServicePointDto[] dtos) {&#10;        return Arrays.stream(dtos)&#10;                .map(DroneServicePointMapper::fromDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/mapper/RestrictedAreaMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/mapper/RestrictedAreaMapper.java" />
              <option name="originalContent" value="package uk.ac.ed.acp.cw2.mapper;&#10;&#10;import uk.ac.ed.acp.cw2.dto.RestrictedAreaDto;&#10;import uk.ac.ed.acp.cw2.entity.RestrictedArea;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.stream.Collectors;&#10;&#10;public final class RestrictedAreaMapper {&#10;    private RestrictedAreaMapper() {}&#10;&#10;    public static RestrictedArea fromDto(RestrictedAreaDto dto) {&#10;        if (dto == null) return null;&#10;&#10;        return RestrictedArea.builder()&#10;                .name(dto.name())&#10;                .id(dto.id())&#10;                .limits(dto.limits())&#10;                .vertices(dto.vertices())&#10;                .build();&#10;    }&#10;&#10;    public static List&lt;RestrictedArea&gt; fromDtoList(RestrictedAreaDto[] dtos) {&#10;        return Arrays.stream(dtos)&#10;                .filter(Objects::nonNull)&#10;                .map(RestrictedAreaMapper::fromDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
              <option name="updatedContent" value="package uk.ac.ed.acp.cw2.mapper;&#10;&#10;import uk.ac.ed.acp.cw2.dto.RestrictedAreaDto;&#10;import uk.ac.ed.acp.cw2.entity.RestrictedArea;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.stream.Collectors;&#10;&#10;public final class RestrictedAreaMapper {&#10;    private RestrictedAreaMapper() {}&#10;&#10;    public static RestrictedArea fromDto(RestrictedAreaDto dto) {&#10;        if (dto == null) return null;&#10;&#10;        return RestrictedArea.builder()&#10;                .name(dto.name())&#10;                .id(dto.id())&#10;                .limits(dto.limits())&#10;                .vertices(dto.vertices())&#10;                .build();&#10;    }&#10;&#10;    public static List&lt;RestrictedArea&gt; fromDtoList(RestrictedAreaDto[] dtos) {&#10;        return Arrays.stream(dtos)&#10;                .filter(Objects::nonNull)&#10;                .map(RestrictedAreaMapper::fromDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/service/DroneService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/uk/ac/ed/acp/cw2/service/DroneService.java" />
              <option name="originalContent" value="package uk.ac.ed.acp.cw2.service;&#10;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.server.ResponseStatusException;&#10;import uk.ac.ed.acp.cw2.dto.MedDispatchRecRequest;&#10;import uk.ac.ed.acp.cw2.entity.Drone;&#10;import uk.ac.ed.acp.cw2.entity.DroneForServicePoint;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;&#10;@Service&#10;public class DroneService {&#10;&#10;    public String[] dronesWithCooling(Boolean state, List&lt;Drone&gt; drones) {&#10;        // Filter by cooling capability and return matching IDs&#10;        return drones.stream()&#10;                .filter(d -&gt; Objects.equals(d.getCooling(), state))&#10;                .map(Drone::getId)&#10;                .toArray(String[]::new);&#10;    }&#10;&#10;    public Drone droneDetails(String id, List&lt;Drone&gt; drones) {&#10;        // Find a drone by id, then map to existing Drone shape&#10;        return drones.stream()&#10;                .filter(d -&gt; id.equals(d.getId()))&#10;                .findFirst()&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Drone not found&quot;));&#10;    }&#10;&#10;    //    &quot;maxCost&quot;: 13.5&#10;    public String[] queryAvailableDrones(MedDispatchRecRequest[] req, List&lt;Drone&gt; drones, List&lt;DroneForServicePoint&gt; dronesForServicePoints) {&#10;        List&lt;Drone&gt; availableDrones = drones;&#10;&#10;        if (req == null) {&#10;            return availableDrones.stream().map(Drone::getId).toArray(String[]::new);&#10;        }&#10;&#10;        // Build a map of drone id -&gt; list of availability windows for fast lookup&#10;        Map&lt;String, List&lt;DroneForServicePoint.Availability&gt;&gt; availabilityMap = new HashMap&lt;&gt;();&#10;        for (DroneForServicePoint sp : dronesForServicePoints) {&#10;            for (DroneForServicePoint.DroneAvailability da : sp.getDrones()) {&#10;                List&lt;DroneForServicePoint.Availability&gt; list = availabilityMap.computeIfAbsent(da.getId(), k -&gt; new ArrayList&lt;&gt;());&#10;                list.addAll(Arrays.asList(da.getAvailability()));&#10;            }&#10;        }&#10;&#10;        for (MedDispatchRecRequest r : req) {&#10;            Double requiredCapacity = r.getRequirements().getCapacity();&#10;            boolean requiresCooling = r.getRequirements().isCooling();&#10;            boolean requiresHeating = r.getRequirements().isHeating();&#10;            LocalDate date = r.getDate();&#10;            LocalTime time = r.getTime();&#10;            // TODO: Only perform attribute-based filtering and use a lower-bound or estimated cost such as \&#10;            //(distance(servicePoint, delivery)/step) × costPerMove + costInitial + costFinal, divided by the number of dispatches;&#10;&#10;            availableDrones = availableDrones.stream()&#10;                    .filter(d -&gt; {&#10;                        if (date == null &amp;&amp; time == null) return true; // no constraint&#10;&#10;                        List&lt;DroneForServicePoint.Availability&gt; avails = availabilityMap.get(d.getId());&#10;&#10;                        // If date provided, check day-of-week match; if time provided, also check the time window&#10;                        if (date != null) {&#10;                            java.time.DayOfWeek dow = date.getDayOfWeek();&#10;                            return avails.stream().anyMatch(a -&gt; a.getDayOfWeek() == dow &amp;&amp;&#10;                                    (time == null || (!a.getFrom().isAfter(time) &amp;&amp; !a.getUntil().isBefore(time))));&#10;                        } else { // date == null but time != null: accept any availability window that contains the time&#10;                            return avails.stream().anyMatch(a -&gt; (!a.getFrom().isAfter(time) &amp;&amp; !a.getUntil().isBefore(time)));&#10;                        }&#10;                    })&#10;                    .filter(d -&gt; {&#10;                        // robust capacity handling: guard nulls, compare safely and clamp small fp negatives&#10;                        Double cap = d.getCapacity();&#10;&#10;                        if (Double.compare(cap, requiredCapacity) &gt;= 0) {&#10;                            double newCap = cap - requiredCapacity;&#10;                            d.setCapacity(newCap);&#10;                            return true;&#10;                        }&#10;                        return false;&#10;                    })&#10;                    .filter(d -&gt; !requiresCooling || Boolean.TRUE.equals(d.getCooling()))&#10;                    .filter(d -&gt; !requiresHeating || Boolean.TRUE.equals(d.getHeating()))&#10;                    .toList();&#10;        }&#10;&#10;&#10;        return availableDrones.stream()&#10;                .map(Drone::getId)&#10;                .toArray(String[]::new);&#10;    }&#10;&#10;    /**&#10;     * Return Drone IDs whose top-level attribute equals the provided string value.&#10;     * Only single-level attributes (no dot paths) are supported and attribute types are&#10;     * String, Boolean, or Number (Integer/Double). All inputs are assumed valid per project constraints.&#10;     */&#10;    public String[] queryAsPath(String attributeName, String value, List&lt;Drone&gt; drones) {&#10;        if (drones == null || attributeName == null) return new String[0];&#10;&#10;        List&lt;String&gt; matched = new ArrayList&lt;&gt;();&#10;        for (Drone d : drones) {&#10;            Object attrVal = readProperty(d, attributeName);&#10;            if (attributeEqualsSimple(attrVal, value)) {&#10;                matched.add(d.getId());&#10;            }&#10;        }&#10;        return matched.toArray(new String[0]);&#10;    }&#10;&#10;    private Object readProperty(Object obj, String propertyName) {&#10;        if (obj == null || propertyName == null) return null;&#10;        Class&lt;?&gt; cls = obj.getClass();&#10;        String cap = propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);&#10;&#10;        // try getter methods: getXxx() then isXxx()&#10;        try {&#10;            Method m = cls.getMethod(&quot;get&quot; + cap);&#10;            return m.invoke(obj);&#10;        } catch (Exception ignored) {}&#10;        try {&#10;            Method m = cls.getMethod(&quot;is&quot; + cap);&#10;            return m.invoke(obj);&#10;        } catch (Exception ignored) {}&#10;&#10;        // fallback: try direct field access&#10;        try {&#10;            Field f = cls.getDeclaredField(propertyName);&#10;            f.setAccessible(true);&#10;            return f.get(obj);&#10;        } catch (Exception ignored) {}&#10;&#10;        return null;&#10;    }&#10;&#10;    private boolean attributeEqualsSimple(Object attrVal, String stringValue) {&#10;        // Given project constraints, attributes are valid and non-null; handle main types&#10;        if (attrVal instanceof String) {&#10;            return attrVal.equals(stringValue);&#10;        }&#10;&#10;        if (attrVal instanceof Boolean) {&#10;            return Boolean.valueOf(stringValue).equals(attrVal);&#10;        }&#10;&#10;        if (attrVal instanceof Number) {&#10;            BigDecimal a = new BigDecimal(attrVal.toString());&#10;            BigDecimal b = new BigDecimal(stringValue);&#10;            return a.compareTo(b) == 0;&#10;        }&#10;&#10;        // fallback&#10;        return attrVal != null &amp;&amp; attrVal.toString().equals(stringValue);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package uk.ac.ed.acp.cw2.service;&#10;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.server.ResponseStatusException;&#10;import uk.ac.ed.acp.cw2.dto.MedDispatchRecRequest;&#10;import uk.ac.ed.acp.cw2.entity.Drone;&#10;import uk.ac.ed.acp.cw2.entity.DroneForServicePoint;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;&#10;@Service&#10;public class DroneService {&#10;&#10;    public String[] dronesWithCooling(Boolean state, List&lt;Drone&gt; drones) {&#10;        // Filter by cooling capability and return matching IDs&#10;        return drones.stream()&#10;                .filter(d -&gt; Objects.equals(d.getCooling(), state))&#10;                .map(Drone::getId)&#10;                .toArray(String[]::new);&#10;    }&#10;&#10;    public Drone droneDetails(String id, List&lt;Drone&gt; drones) {&#10;        // Find a drone by id, then map to existing Drone shape&#10;        return drones.stream()&#10;                .filter(d -&gt; id.equals(d.getId()))&#10;                .findFirst()&#10;                .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Drone not found&quot;));&#10;    }&#10;&#10;    //    &quot;maxCost&quot;: 13.5&#10;    public String[] queryAvailableDrones(MedDispatchRecRequest[] req, List&lt;Drone&gt; drones, List&lt;DroneForServicePoint&gt; dronesForServicePoints) {&#10;        List&lt;Drone&gt; availableDrones = drones;&#10;&#10;        if (req == null) {&#10;            return availableDrones.stream().map(Drone::getId).toArray(String[]::new);&#10;        }&#10;&#10;        // Build a map of drone id -&gt; list of availability windows for fast lookup&#10;        Map&lt;String, List&lt;DroneForServicePoint.Availability&gt;&gt; availabilityMap = new HashMap&lt;&gt;();&#10;        for (DroneForServicePoint sp : dronesForServicePoints) {&#10;            for (DroneForServicePoint.DroneAvailability da : sp.getDrones()) {&#10;                List&lt;DroneForServicePoint.Availability&gt; list = availabilityMap.computeIfAbsent(da.getId(), k -&gt; new ArrayList&lt;&gt;());&#10;                list.addAll(Arrays.asList(da.getAvailability()));&#10;            }&#10;        }&#10;&#10;        for (MedDispatchRecRequest r : req) {&#10;            Double requiredCapacity = r.getRequirements().getCapacity();&#10;            boolean requiresCooling = r.getRequirements().isCooling();&#10;            boolean requiresHeating = r.getRequirements().isHeating();&#10;            LocalDate date = r.getDate();&#10;            LocalTime time = r.getTime();&#10;            // TODO: Only perform attribute-based filtering and use a lower-bound or estimated cost such as \&#10;            //(distance(servicePoint, delivery)/step) × costPerMove + costInitial + costFinal, divided by the number of dispatches;&#10;&#10;            availableDrones = availableDrones.stream()&#10;                    .filter(d -&gt; {&#10;                        if (date == null &amp;&amp; time == null) return true; // no constraint&#10;&#10;                        List&lt;DroneForServicePoint.Availability&gt; avails = availabilityMap.get(d.getId());&#10;&#10;                        // If date provided, check day-of-week match; if time provided, also check the time window&#10;                        if (date != null) {&#10;                            java.time.DayOfWeek dow = date.getDayOfWeek();&#10;                            return avails.stream().anyMatch(a -&gt; a.getDayOfWeek() == dow &amp;&amp;&#10;                                    (time == null || (!a.getFrom().isAfter(time) &amp;&amp; !a.getUntil().isBefore(time))));&#10;                        } else { // date == null but time != null: accept any availability window that contains the time&#10;                            return avails.stream().anyMatch(a -&gt; (!a.getFrom().isAfter(time) &amp;&amp; !a.getUntil().isBefore(time)));&#10;                        }&#10;                    })&#10;                    .filter(d -&gt; {&#10;                        // robust capacity handling: guard nulls, compare safely and clamp small fp negatives&#10;                        Double cap = d.getCapacity();&#10;&#10;                        if (Double.compare(cap, requiredCapacity) &gt;= 0) {&#10;                            double newCap = cap - requiredCapacity;&#10;                            d.setCapacity(newCap);&#10;                            return true;&#10;                        }&#10;                        return false;&#10;                    })&#10;                    .filter(d -&gt; !requiresCooling || Boolean.TRUE.equals(d.getCooling()))&#10;                    .filter(d -&gt; !requiresHeating || Boolean.TRUE.equals(d.getHeating()))&#10;                    .toList();&#10;        }&#10;&#10;&#10;        return availableDrones.stream()&#10;                .map(Drone::getId)&#10;                .toArray(String[]::new);&#10;    }&#10;&#10;    /**&#10;     * Return Drone IDs whose top-level attribute equals the provided string value.&#10;     * Only single-level attributes (no dot paths) are supported and attribute types are&#10;     * String, Boolean, or Number (Integer/Double). All inputs are assumed valid per project constraints.&#10;     */&#10;    public String[] queryAsPath(String attributeName, String value, List&lt;Drone&gt; drones) {&#10;        if (drones == null || attributeName == null) return new String[0];&#10;&#10;        List&lt;String&gt; matched = new ArrayList&lt;&gt;();&#10;        for (Drone d : drones) {&#10;            Object attrVal = readProperty(d, attributeName);&#10;            if (attributeEqualsSimple(attrVal, value)) {&#10;                matched.add(d.getId());&#10;            }&#10;        }&#10;        return matched.toArray(new String[0]);&#10;    }&#10;&#10;    private Object readProperty(Object obj, String propertyName) {&#10;        if (obj == null || propertyName == null) return null;&#10;        Class&lt;?&gt; cls = obj.getClass();&#10;        String cap = propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);&#10;&#10;        // try getter methods: getXxx() then isXxx()&#10;        try {&#10;            Method m = cls.getMethod(&quot;get&quot; + cap);&#10;            return m.invoke(obj);&#10;        } catch (Exception ignored) {}&#10;        try {&#10;            Method m = cls.getMethod(&quot;is&quot; + cap);&#10;            return m.invoke(obj);&#10;        } catch (Exception ignored) {}&#10;&#10;        // fallback: try direct field access&#10;        try {&#10;            Field f = cls.getDeclaredField(propertyName);&#10;            f.setAccessible(true);&#10;            return f.get(obj);&#10;        } catch (Exception ignored) {}&#10;&#10;        return null;&#10;    }&#10;&#10;    private boolean attributeEqualsSimple(Object attrVal, String stringValue) {&#10;        // Given project constraints, attributes are valid and non-null; handle main types&#10;        if (attrVal instanceof String) {&#10;            return attrVal.equals(stringValue);&#10;        }&#10;&#10;        if (attrVal instanceof Boolean) {&#10;            return Boolean.valueOf(stringValue).equals(attrVal);&#10;        }&#10;&#10;        if (attrVal instanceof Number) {&#10;            BigDecimal a = new BigDecimal(attrVal.toString());&#10;            BigDecimal b = new BigDecimal(stringValue);&#10;            return a.compareTo(b) == 0;&#10;        }&#10;&#10;        // fallback&#10;        return attrVal != null &amp;&amp; attrVal.toString().equals(stringValue);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>